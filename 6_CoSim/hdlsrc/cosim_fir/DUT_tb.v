// -------------------------------------------------------------
//
// Module: DUT_tb_pkg
// Path: hdlsrc\cosim_fir
// Created: 2015-03-16 17:10:09
// Generated by MATLAB 8.5 and HDL Coder 3.6
// Description: test bench tasks, parameters
//
//
// -------------------------------------------------------------
`timescale 1 ns / 1 ns 

module DUT_tb;

  task Zero_Order_Hold_out1_task; 
    input          clk;
    input          reset;
    input          rdenb;
    inout  [13:0]  addr;
    output         done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 10000)
          addr = addr; 
        else
          addr = #1 addr + 1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
    else if (addr == 10000)
      done = 1; 
    else
      done = 0; 

  end
  endtask // Zero_Order_Hold_out1_task

  task Out1_task; 
    input          clk;
    input          reset;
    input          rdenb;
    inout  [13:0]  addr;
    output         done;
  begin

    // Counter to generate the address
    if (reset == 1) 
      addr = 0;
    else begin
      if (rdenb == 1) begin
        if (addr == 10000)
          addr = addr; 
        else
          addr = #1  addr + 1; 
      end
    end

    // Done Signal generation.
    if (reset == 1)
      done = 0; 
    else if (addr == 10000)
      done = 1; 
    else
      done = 0; 

  end
  endtask // Out1_task

 // Constants
 parameter clk_high                         = 5;
 parameter clk_low                          = 5;
 parameter clk_period                       = 10;
 parameter clk_hold                         = 2;
// -------------------------------------------------------------
//
// Module: DUT_tb_data
// Path: hdlsrc\cosim_fir
// Created: 2015-03-16 17:10:09
// Generated by MATLAB 8.5 and HDL Coder 3.6
// Description: test bench data
//
//
// -------------------------------------------------------------
 reg  signed [15:0] Zero_Order_Hold_out1_force [0:10000];
 reg  signed [18:0] Out1_expected [0:10000];

// -------------------------------------------------------------
//
// Module: DUT_tb
// Path: hdlsrc\cosim_fir
// Created: 2015-03-16 17:10:09
// Generated by MATLAB 8.5 and HDL Coder 3.6
// Hierarchy Level: 1
//
//
// -------------------------------------------------------------
  parameter MAX_ERROR_COUNT = 10001; //uint32


 // Signals
  reg  clk; // boolean
  reg  reset; // boolean
  reg  clk_enable; // boolean
  reg  signed [15:0] In1; // sfix16_En14
  wire  ce_out; // boolean
  wire signed [18:0] Out1; // sfix19_En14

  reg  tb_enb; // boolean
  wire srcDone; // boolean
  wire snkDone; // boolean
  wire testFailure; // boolean
  reg  tbenb_dly; // boolean
  reg  rdEnb; // boolean
  wire Zero_Order_Hold_out1_rdenb; // boolean
  reg  [13:0] Zero_Order_Hold_out1_addr; // ufix14
  reg  Zero_Order_Hold_out1_done; // boolean
  reg  Out1_testFailure; // boolean
  integer Out1_errCnt; // uint32
  wire Out1_rdenb; // boolean
  reg  [13:0] Out1_addr; // ufix14
  reg  Out1_done; // boolean
  wire signed [18:0] Out1_ref; // sfix19_En14
  reg  check1_Done; // boolean
  integer fp_In1; // uint32
  integer rewindFpStatus_In1; // uint32
  integer rStatus_In1; // uint32
  reg  signed [15:0] fpVal_In1; // sfix16_En14
  integer fp_Out1; // uint32
  integer rewindFpStatus_Out1; // uint32
  integer rStatus_Out1; // uint32
  reg  signed [18:0] fpVal_Out1; // sfix19_En14

 // Module Instances
  DUT u_DUT
    (
    .clk(clk),
    .reset(reset),
    .clk_enable(clk_enable),
    .In1(In1),
    .ce_out(ce_out),
    .Out1(Out1)
    );


 // Block Statements
  // -------------------------------------------------------------
  // Driving the test bench enable
  // -------------------------------------------------------------

  always @(reset, snkDone)
  begin
    if (reset == 1'b1)
      tb_enb <= 1'b0;
    else if (snkDone == 1'b0 )
      tb_enb <= 1'b1;
    else begin
    # (clk_period * 2);
      tb_enb <= 1'b0;
    end
  end

  always @(posedge clk or posedge reset) // completed_msg
  begin
    if (reset) begin 
       // Nothing to reset.
    end 
    else begin 
      if (snkDone == 1) begin
        if (testFailure == 0)
              $display("**************TEST COMPLETED (PASSED)**************");
        else
              $display("**************TEST COMPLETED (FAILED)**************");
      end
    end
  end // completed_msg;

  // -------------------------------------------------------------
  // System Clock (fast clock) and reset
  // -------------------------------------------------------------

  always  // clock generation
  begin // clk_gen
    clk <= 1'b1;
    # clk_high;
    clk <= 1'b0;
    # clk_low;
    if (snkDone == 1) begin
      clk <= 1'b1;
      # clk_high;
      clk <= 1'b0;
      # clk_low;
      $stop;
    end
  end  // clk_gen

  initial  // reset block
  begin // reset_gen
    reset <= 1'b1;
    # (clk_period * 2);
    @ (posedge clk);
    # (clk_hold);
    reset <= 1'b0;
  end  // reset_gen

  // -------------------------------------------------------------
  // Testbench clock enable
  // -------------------------------------------------------------

  always @ (posedge clk or posedge reset)
    begin: tb_enb_delay
      if (reset == 1'b1) begin
        tbenb_dly <= 1'b0;
      end
      else begin
        if (tb_enb == 1'b1) begin
          tbenb_dly <= tb_enb;
        end
      end
    end // tb_enb_delay

  always @(snkDone, tbenb_dly)
  begin
    if (snkDone == 0)
      rdEnb <= tbenb_dly;
    else
      rdEnb <= 0;
  end

  // -------------------------------------------------------------
  // Read the data and transmit it to the DUT
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    Zero_Order_Hold_out1_task(clk,reset,
                              Zero_Order_Hold_out1_rdenb,Zero_Order_Hold_out1_addr,
                              Zero_Order_Hold_out1_done);
  end

  assign Zero_Order_Hold_out1_rdenb = rdEnb;

  always @ (Zero_Order_Hold_out1_rdenb, Zero_Order_Hold_out1_addr)
  begin // stimuli_Zero_Order_Hold_out1_In1
    if (Zero_Order_Hold_out1_rdenb == 1) begin
    if (reset) begin 
        rewindFpStatus_In1 <= $rewind (fp_In1);
    end else
        rStatus_In1 <= $fscanf (fp_In1,"%h",fpVal_In1);
        In1 <= # clk_hold fpVal_In1;
    end
  end // stimuli_Zero_Order_Hold_out1_In1

  // -------------------------------------------------------------
  // Create done signal for Input data
  // -------------------------------------------------------------

  assign srcDone = Zero_Order_Hold_out1_done;

  // -------------------------------------------------------------
  //  Checker: Checking the data received from the DUT.
  // -------------------------------------------------------------

  always @(posedge clk or posedge reset)
  begin
    Out1_task(clk,reset,
              Out1_rdenb,Out1_addr,
              Out1_done);
  end

  assign Out1_rdenb = ce_out;

  assign Out1_ref = fpVal_Out1;


  always @ (posedge clk or posedge reset) // checker_Out1
  begin
    if (reset == 1) begin
      Out1_testFailure <= 0;
      Out1_errCnt <= 0;
      rewindFpStatus_Out1 <= $rewind (fp_Out1);
    end 
    else begin 
      if (Out1_rdenb == 1 ) begin 
        rStatus_Out1 <= $fscanf(fp_Out1,"%h",fpVal_Out1);
        if (Out1 !== fpVal_Out1) begin
           Out1_errCnt <= Out1_errCnt + 1;
           Out1_testFailure <= 1;
               $display("ERROR in Out1 at time %t : Expected '%h' Actual '%h'", 
                    $time, fpVal_Out1, Out1);
           if (Out1_errCnt >= MAX_ERROR_COUNT) 
             $display("Warning: Number of errors for Out1 have exceeded the maximum error limit");
        end

      end
    end
  end // checker_Out1

  always @ (posedge clk or posedge reset) // checkDone_1
  begin
    if (reset == 1)
      check1_Done <= 0;
    else if ((check1_Done == 0) && (Out1_done == 1) && (Out1_rdenb == 1))
      check1_Done <= 1;
  end

  // -------------------------------------------------------------
  // Create done and test failure signal for output data
  // -------------------------------------------------------------

  assign snkDone = check1_Done;

  assign testFailure = Out1_testFailure;

  // -------------------------------------------------------------
  // Global clock enable
  // -------------------------------------------------------------
  always @(snkDone, tbenb_dly)
  begin
    if (snkDone == 0)
      # clk_hold clk_enable <= tbenb_dly;
    else
      # clk_hold clk_enable <= 0;
  end

   initial
     begin
        fp_In1 = $fopen("In1.dat", "r");
        fp_Out1 = $fopen("Out1.dat", "r");
     end

 // Assignment Statements



endmodule // DUT_tb
